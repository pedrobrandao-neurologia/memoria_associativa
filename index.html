<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teste de Memória Associativa (PAL)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.autotable.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        .card {
            transition: transform 0.4s ease-in-out;
            transform-style: preserve-3d;
            /* BUG FIX: Apply base transform here to ensure it's always present */
            transform: translate(-50%, -50%);
        }
        .card.is-flipped {
            /* BUG FIX: Combine the positioning and rotation transforms */
            transform: translate(-50%, -50%) rotateY(180deg);
        }
        .card-face {
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            position: absolute;
            width: 100%;
            height: 100%;
        }
        .card-face-back {
            transform: rotateY(180deg);
            padding: 8px; /* Add padding for SVGs */
        }
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        .pulse-success {
            animation: pulse-success 0.5s ease-in-out;
        }
        @keyframes pulse-success {
            0% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
        }
        .export-btn {
            padding: 0.5rem 1rem;
            font-weight: bold;
            border-radius: 0.5rem;
            transition: background-color 0.2s;
            color: white;
            margin: 0.25rem;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">
    <div id="app" class="w-full max-w-4xl mx-auto p-4 md:p-8">
        
        <!-- Tela de Início -->
        <div id="start-screen" class="bg-white rounded-xl shadow-lg p-8 text-center">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">Teste de Memória Associativa (PAL)</h1>
            <p class="text-gray-600 mb-6">Este teste avalia a sua capacidade de aprender e recordar a localização de padrões.</p>
            <div class="max-w-md mx-auto mb-6">
                <label for="subject-id" class="block text-sm font-medium text-gray-700 mb-1">ID do Sujeito</label>
                <input type="text" id="subject-id" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="Insira o ID do sujeito aqui">
            </div>
            <div class="text-left max-w-2xl mx-auto space-y-3 text-gray-700 mb-8">
                <p><strong>Instruções:</strong></p>
                <p>1. No início de cada fase, caixas na tela se abrirão uma a uma para revelar um padrão em seu interior.</p>
                <p>2. Tente memorizar qual padrão pertence a qual caixa.</p>
                <p>3. Após todos os padrões terem sido mostrados, um padrão aparecerá no centro da tela.</p>
                <p>4. A sua tarefa é clicar na caixa onde viu esse padrão. Se errar, pode tentar novamente.</p>
                 <p>5. Se errar alguma localização na primeira tentativa, a sequência será mostrada novamente.</p>
            </div>
            <button id="start-btn" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-700 transition-colors text-lg">
                Iniciar Teste
            </button>
        </div>

        <!-- Tela do Teste -->
        <div id="test-screen" class="hidden">
            <div class="w-full max-w-xl mx-auto">
                <div class="relative w-full aspect-square">
                    <div id="grid-container" class="absolute inset-0"></div>
                    <div id="recall-stimulus-container" class="absolute inset-0 flex items-center justify-center pointer-events-none">
                        <div id="recall-stimulus" class="hidden w-24 h-24 bg-white rounded-lg shadow-md flex items-center justify-center text-5xl p-2"></div>
                    </div>
                </div>
                <div class="relative h-28 flex items-center justify-center">
                     <div id="message-area" class="text-xl font-medium text-gray-700 text-center"></div>
                </div>
            </div>
        </div>


        <!-- Tela de Resultados -->
        <div id="results-screen" class="hidden bg-white rounded-xl shadow-lg p-8">
            <h2 class="text-3xl font-bold text-gray-800 mb-2 text-center">Resultados do Teste</h2>
            <p id="results-subject-id" class="text-center text-gray-500 mb-6"></p>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                <div class="bg-gray-100 p-4 rounded-lg">
                    <h3 class="font-bold text-gray-700 text-lg">Métricas Principais</h3>
                    <div id="summary-results" class="mt-2 space-y-2 text-gray-600"></div>
                </div>
                <div class="bg-gray-100 p-4 rounded-lg">
                    <h3 class="font-bold text-gray-700 text-lg">Desempenho por Estágio</h3>
                    <div id="stage-results" class="mt-2 space-y-2 text-gray-600"></div>
                </div>
            </div>
            <div class="text-center mt-8 border-t pt-6">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <h3 class="font-bold text-gray-700 text-lg mb-2">Exportar Resumo</h3>
                        <button id="export-csv-summary-btn" class="export-btn bg-green-600 hover:bg-green-700">CSV</button>
                        <button id="export-json-summary-btn" class="export-btn bg-yellow-500 hover:bg-yellow-600">JSON</button>
                        <button id="export-pdf-summary-btn" class="export-btn bg-red-600 hover:bg-red-700">PDF</button>
                    </div>
                    <div>
                        <h3 class="font-bold text-gray-700 text-lg mb-2">Exportar Relatório Detalhado</h3>
                        <button id="export-csv-detailed-btn" class="export-btn bg-green-700 hover:bg-green-800">CSV</button>
                        <button id="export-json-detailed-btn" class="export-btn bg-yellow-600 hover:bg-yellow-700">JSON</button>
                        <button id="export-pdf-detailed-btn" class="export-btn bg-red-700 hover:bg-red-800">PDF</button>
                    </div>
                </div>
                <button id="restart-btn" class="bg-gray-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-gray-700 transition-colors mt-8">
                    Reiniciar Teste
                </button>
            </div>
        </div>

    </div>

    <script>
    class PALTest {
        constructor() {
            // --- Configuração do Teste ---
            this.STAGES_CONFIG = [2, 4, 6, 8];
            this.MAX_TOTAL_ERRORS = 10;
            this.MAX_ERRORS_PER_STAGE = 6;
            this.ERROR_PENALTY_PER_STAGE = 10;
            this.ABSTRACT_STIMULI = [
                '<svg viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="#3498db" /></svg>',
                '<svg viewBox="0 0 100 100"><rect width="90" height="90" x="5" y="5" fill="#e74c3c" /></svg>',
                '<svg viewBox="0 0 100 100"><polygon points="50,5 95,95 5,95" fill="#2ecc71" /></svg>',
                '<svg viewBox="0 0 100 100"><polygon points="50,5 61,40 98,40 68,62 79,96 50,75 21,96 32,62 2,40 39,40" fill="#f1c40f" /></svg>',
                '<svg viewBox="0 0 100 100"><path d="M50 5 L95 50 L50 95 L5 50 Z" fill="#9b59b6" /></svg>',
                '<svg viewBox="0 0 100 100"><path d="M10 10 L90 90 M90 10 L10 90" stroke="#e67e22" stroke-width="15" /></svg>',
                '<svg viewBox="0 0 100 100"><path d="M20,80 A40,40 0 0,1 80,20" stroke="#34495e" stroke-width="10" fill="none" /></svg>',
                '<svg viewBox="0 0 100 100"><path d="M10 50 Q 30 10, 50 50 T 90 50" stroke="#1abc9c" stroke-width="10" fill="none"/></svg>',
                '<svg viewBox="0 0 100 100"><polygon points="10,10 40,90 90,20 20,80 80,10" fill="#e91e63" /></svg>',
                '<svg viewBox="0 0 100 100"><polygon points="50,10 90,35 90,75 50,95 10,75 10,35" fill="#795548" /></svg>',
                '<svg viewBox="0 0 100 100"><path d="M20 80 L50 20 L80 80 Z" stroke="#bdc3c7" stroke-width="10" fill="none" /></svg>',
                '<svg viewBox="0 0 100 100"><path d="M50,10 A40,40,0,1,1,50,90" fill="#8e44ad" /><path d="M50,10 A40,40,0,1,0,50,90" fill="#f0f2f5" /></svg>',
                '<svg viewBox="0 0 100 100"><path d="M20 20 H 80 V 80 H 20 Z" stroke="#c0392b" stroke-width="10" fill="none" /></svg>',
                '<svg viewBox="0 0 100 100"><path d="M 50,10 L 80,90 L 20,90 Z" fill="#d35400" /></svg>',
                '<svg viewBox="0 0 100 100"><path d="M 20,50 C 20,20 80,20 80,50 S 20,80 20,50" fill="#2980b9" /></svg>',
                '<svg viewBox="0 0 100 100"><rect x="10" y="45" width="80" height="10" fill="#27ae60" /><rect x="45" y="10" width="10" height="80" fill="#27ae60" /></svg>',
                '<svg viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" stroke="#f39c12" stroke-width="10" fill="none" /><circle cx="50" cy="50" r="20" fill="#f39c12" /></svg>',
                '<svg viewBox="0 0 100 100"><path d="M10,90 C40,10 60,10 90,90" stroke="#d35400" stroke-width="10" fill="none"/></svg>',
                '<svg viewBox="0 0 100 100"><path d="M15 15 L85 85 M15 85 L85 15" stroke="#c0392b" stroke-width="12" stroke-linecap="round" /></svg>',
                '<svg viewBox="0 0 100 100"><path d="M50 10 V 90 M10 50 H 90" stroke="#7f8c8d" stroke-width="10" /></svg>'
            ];
            this.BOX_COUNT = 8; 

            // --- Elementos da UI ---
            this.ui = {
                subjectIdInput: document.getElementById('subject-id'),
                startScreen: document.getElementById('start-screen'),
                testScreen: document.getElementById('test-screen'),
                resultsScreen: document.getElementById('results-screen'),
                startBtn: document.getElementById('start-btn'),
                restartBtn: document.getElementById('restart-btn'),
                exportCsvSummaryBtn: document.getElementById('export-csv-summary-btn'),
                exportJsonSummaryBtn: document.getElementById('export-json-summary-btn'),
                exportPdfSummaryBtn: document.getElementById('export-pdf-summary-btn'),
                exportCsvDetailedBtn: document.getElementById('export-csv-detailed-btn'),
                exportJsonDetailedBtn: document.getElementById('export-json-detailed-btn'),
                exportPdfDetailedBtn: document.getElementById('export-pdf-detailed-btn'),
                gridContainer: document.getElementById('grid-container'),
                recallStimulus: document.getElementById('recall-stimulus'),
                messageArea: document.getElementById('message-area'),
                summaryResults: document.getElementById('summary-results'),
                stageResults: document.getElementById('stage-results'),
                resultsSubjectId: document.getElementById('results-subject-id'),
            };

            // --- Estado do Teste ---
            this.state = {};
            this.resetState();
            
            this.bindEvents();
        }

        resetState() {
            this.state = {
                currentStageIndex: 0,
                isPresentationPhase: false,
                isRecallPhase: false,
                patternsForStage: [],
                stimuliPool: [],
                presentationCount: 1,
                responseStartTime: 0,
                correctlyRecalledInStage: [],
                resolveClick: null,
                results: {
                    subjectID: '',
                    stagesCompleted: 0,
                    totalErrors: 0, // PALTE
                    totalFirstAttemptSuccesses: 0,
                    PALTEA: 0, // Total Errors Adjusted
                    PALMETS: 0, // Mean Errors to Success
                    stages: {},
                    trialLog: []
                }
            };
            this.STAGES_CONFIG.forEach(numPatterns => {
                 this.state.results.stages[numPatterns] = {
                    errors: 0,
                    firstAttemptSuccesses: 0,
                    completed: false
                };
            });
            this.ui.subjectIdInput.value = '';
        }

        bindEvents() {
            this.ui.startBtn.addEventListener('click', () => this.startTest());
            this.ui.restartBtn.addEventListener('click', () => this.startTest());
            this.ui.exportCsvSummaryBtn.addEventListener('click', () => this.exportController('csv', 'summary'));
            this.ui.exportJsonSummaryBtn.addEventListener('click', () => this.exportController('json', 'summary'));
            this.ui.exportPdfSummaryBtn.addEventListener('click', () => this.exportController('pdf', 'summary'));
            this.ui.exportCsvDetailedBtn.addEventListener('click', () => this.exportController('csv', 'detailed'));
            this.ui.exportJsonDetailedBtn.addEventListener('click', () => this.exportController('json', 'detailed'));
            this.ui.exportPdfDetailedBtn.addEventListener('click', () => this.exportController('pdf', 'detailed'));
        }

        startTest() {
            const subjectID = this.ui.subjectIdInput.value.trim();
            if (!subjectID) {
                alert('Por favor, insira um ID para o sujeito antes de iniciar.');
                return;
            }
            this.resetState();
            this.state.results.subjectID = subjectID;
            this.state.stimuliPool = this.shuffleArray([...this.ABSTRACT_STIMULI.keys()]);

            this.ui.startScreen.classList.add('hidden');
            this.ui.resultsScreen.classList.add('hidden');
            this.ui.testScreen.classList.remove('hidden');

            requestAnimationFrame(() => {
                this.setupGrid();
                this.runStage();
            });
        }

        setupGrid() {
            this.ui.gridContainer.innerHTML = '';
            const containerWidth = this.ui.gridContainer.offsetWidth;
            if (containerWidth === 0) { return; }

            const radius = containerWidth / 2 * 0.8;
            const center = { x: containerWidth / 2, y: containerWidth / 2 };
            
            for (let i = 0; i < this.BOX_COUNT; i++) {
                const angle = (i / this.BOX_COUNT) * 2 * Math.PI - (Math.PI / 2);
                const x = center.x + radius * Math.cos(angle);
                const y = center.y + radius * Math.sin(angle);
                const card = document.createElement('div');
                card.className = 'card absolute w-24 h-24 cursor-pointer';
                card.style.left = `${x}px`;
                card.style.top = `${y}px`;
                card.dataset.id = i;
                card.innerHTML = `
                    <div class="card-face w-full h-full rounded-lg bg-white shadow-md border-2 border-gray-300"></div>
                    <div class="card-face card-face-back w-full h-full rounded-lg bg-white shadow-lg border-2 border-blue-400 flex items-center justify-center"></div>`;
                this.ui.gridContainer.appendChild(card);
                card.addEventListener('click', () => this.handleBoxClick(i));
            }
        }
        
        async runStage() {
            if (this.state.currentStageIndex >= this.STAGES_CONFIG.length) {
                this.endTest();
                return;
            }

            const stageKey = this.STAGES_CONFIG[this.state.currentStageIndex];
            this.prepareStagePatterns(stageKey);
            this.state.correctlyRecalledInStage = [];

            // First Presentation
            this.state.presentationCount = 1;
            await this.runPresentationPhase();
            
            const patternsToRecall = this.shuffleArray([...this.state.patternsForStage]);
            const recallStatus = await this.runRecallLoop(patternsToRecall);

            if (recallStatus === 'TEST_ENDED') return;

            // Re-presentation if an error occurred on the first pass
            if (recallStatus === 'HAD_ERROR') {
                this.state.presentationCount = 2;
                this.ui.messageArea.textContent = 'Vamos rever as posições...';
                await this.delay(2000);
                await this.runPresentationPhase(); // Re-present all stimuli

                // Only test the ones that were not yet answered correctly
                const remainingPatterns = patternsToRecall.filter(p =>
                    !this.state.correctlyRecalledInStage.some(c => c.stimulusId === p.stimulusId)
                );
                
                const secondRecallStatus = await this.runRecallLoop(remainingPatterns);
                if (secondRecallStatus === 'TEST_ENDED') return;
            }

            // --- Stage Finalization ---
            this.state.results.stages[stageKey].completed = true;
            if (recallStatus === 'COMPLETED_FLAWLESSLY') {
                this.state.results.stagesCompleted = stageKey;
            }

            this.state.currentStageIndex++;
            this.ui.messageArea.textContent = `Estágio concluído!`;
            await this.delay(2000);
            this.runStage();
        }
        
        prepareStagePatterns(numPatterns) {
            const availablePositions = this.shuffleArray([...Array(this.BOX_COUNT).keys()]);
            this.state.patternsForStage = [];
            for (let i = 0; i < numPatterns; i++) {
                const stimulusIndex = this.state.stimuliPool.pop();
                if (stimulusIndex === undefined) {
                    console.error("Not enough unique stimuli for the test.");
                    this.endTest();
                    return;
                }
                this.state.patternsForStage.push({
                    stimulusSVG: this.ABSTRACT_STIMULI[stimulusIndex],
                    stimulusId: `Forma ${stimulusIndex + 1}`,
                    position: availablePositions[i]
                });
            }
        }

        async runPresentationPhase() {
            this.state.isPresentationPhase = true;
            this.ui.messageArea.textContent = 'Memorize as posições...';
            await this.delay(1500);
            for (const pattern of this.state.patternsForStage) {
                const card = this.ui.gridContainer.children[pattern.position];
                const cardBack = card.querySelector('.card-face-back');
                cardBack.innerHTML = pattern.stimulusSVG;
                card.classList.add('is-flipped');
                await this.delay(2500);
                card.classList.remove('is-flipped');
                await this.delay(500);
            }
            this.state.isPresentationPhase = false;
        }
        
        async runRecallLoop(patternsToTest) {
            this.state.isRecallPhase = true;

            for (const correctPattern of patternsToTest) {
                for (let attempt = 1; attempt <= 2; attempt++) {
                    this.showNextRecallStimulus(correctPattern);
                    
                    const clickPromise = new Promise(resolve => { this.state.resolveClick = resolve; });
                    const clickedPosition = await clickPromise;
                    this.ui.recallStimulus.classList.add('hidden');

                    if (clickedPosition === null) return 'TEST_ENDED'; 

                    const isCorrect = clickedPosition === correctPattern.position;
                    const responseTime = Date.now() - this.state.responseStartTime;
                    const clickedCard = this.ui.gridContainer.children[clickedPosition];

                    this.state.results.trialLog.push({
                        stage: this.STAGES_CONFIG[this.state.currentStageIndex],
                        stimulusId: correctPattern.stimulusId,
                        correctPosition: correctPattern.position,
                        clickedPosition: clickedPosition,
                        isCorrect: isCorrect,
                        attempt: attempt,
                        presentation: this.state.presentationCount,
                        responseTime: responseTime
                    });

                    if (isCorrect) {
                        if (attempt === 1 && this.state.presentationCount === 1) {
                            this.state.results.stages[this.STAGES_CONFIG[this.state.currentStageIndex]].firstAttemptSuccesses++;
                            this.state.results.totalFirstAttemptSuccesses++;
                        }
                        this.state.correctlyRecalledInStage.push(correctPattern);
                        await this.handleCorrectVisuals(clickedCard);
                        break; 
                    } else { 
                        if (this.state.presentationCount === 1) {
                            await this.handleIncorrectVisualsAndLogic(clickedCard, true);
                            this.state.isRecallPhase = false;
                            return 'HAD_ERROR'; 
                        }
                        
                        const shouldEndTest = await this.handleIncorrectVisualsAndLogic(clickedCard, attempt === 1);
                        if (shouldEndTest) return 'TEST_ENDED';
                        
                        if (attempt === 2) { break; }
                    }
                } 
            } 

            this.state.isRecallPhase = false;
            return 'COMPLETED_FLAWLESSLY'; 
        }

        showNextRecallStimulus(pattern) {
            this.ui.messageArea.textContent = 'Onde estava este padrão?';
            this.ui.recallStimulus.innerHTML = pattern.stimulusSVG;
            this.ui.recallStimulus.classList.remove('hidden');
            this.state.responseStartTime = Date.now();
        }

        handleBoxClick(clickedPosition) {
            if (!this.state.isRecallPhase || !this.state.resolveClick) return;
            this.state.resolveClick(clickedPosition);
            this.state.resolveClick = null;
        }
        
        async handleCorrectVisuals(card) {
            this.ui.messageArea.textContent = 'Correto!';
            card.classList.add('pulse-success');
            await this.delay(1500);
            card.classList.remove('pulse-success');
        }
        
        async handleIncorrectVisualsAndLogic(card, countError) {
            card.classList.add('shake');
            this.ui.messageArea.textContent = 'Incorreto.';

            if (countError) {
                const stageKey = this.STAGES_CONFIG[this.state.currentStageIndex];
                this.state.results.stages[stageKey].errors++;
                this.state.results.totalErrors++;
            }

            const stageKey = this.STAGES_CONFIG[this.state.currentStageIndex];
            if (this.state.results.stages[stageKey].errors >= this.MAX_ERRORS_PER_STAGE || this.state.results.totalErrors >= this.MAX_TOTAL_ERRORS) {
                this.ui.messageArea.textContent = this.state.results.stages[stageKey].errors >= this.MAX_ERRORS_PER_STAGE
                    ? 'Muitos erros neste estágio.'
                    : 'Teste interrompido.';
                
                if(this.state.resolveClick) this.state.resolveClick(null);

                await this.delay(1500);
                card.classList.remove('shake');
                this.endTest();
                return true; // Indicates test should end
            }
            
            await this.delay(1500);
            card.classList.remove('shake');
            if (this.state.presentationCount > 1 && this.state.currentAttempt < 2) {
                 this.ui.messageArea.textContent = 'Tente o mesmo item novamente.';
            }
            return false;
        }
        
        calculateAdvancedMetrics() {
            // PALTEA: Total Errors (Adjusted)
            let adjustedErrors = this.state.results.totalErrors;
            const lastStageAttemptedIndex = this.state.currentStageIndex;
            this.STAGES_CONFIG.forEach((stage, index) => {
                if(index >= lastStageAttemptedIndex) {
                     if (!this.state.results.stages[stage].completed) {
                         adjustedErrors += this.ERROR_PENALTY_PER_STAGE;
                     }
                }
            });
            this.state.results.PALTEA = adjustedErrors;

            // PALMETS: Mean errors to success on completed stages
            let errorsOnCompletedStages = 0;
            let completedStagesCount = 0;
            this.STAGES_CONFIG.forEach(stageKey => {
                const stage = this.state.results.stages[stageKey];
                if (stage.completed) {
                    errorsOnCompletedStages += stage.errors;
                    completedStagesCount++;
                }
            });
            this.state.results.PALMETS = completedStagesCount > 0 ? parseFloat((errorsOnCompletedStages / completedStagesCount).toFixed(2)) : 0;
        }

        endTest() {
            this.state.isRecallPhase = false; // Ensure recall phase is stopped
            this.calculateAdvancedMetrics();
            this.ui.testScreen.classList.add('hidden');
            this.displayResults();
            this.ui.resultsScreen.classList.remove('hidden');
        }

        displayResults() {
            const res = this.state.results;
            this.ui.resultsSubjectId.textContent = `Resultados para o sujeito: ${res.subjectID}`;
            this.ui.summaryResults.innerHTML = `
                <p><strong>Nível Máximo Concluído (1ª Apres.):</strong> ${res.stagesCompleted}</p>
                <p><strong>Total de Erros (PALTE):</strong> ${res.totalErrors}</p>
                <p><strong>Total de Erros Ajustado (PALTEA):</strong> ${res.PALTEA}</p>
                <p><strong>Erros Médios para o Sucesso (PALMETS):</strong> ${res.PALMETS}</p>
                <p><strong>Acertos na 1ª Tentativa (Item):</strong> ${res.totalFirstAttemptSuccesses}</p>
            `;
            let stageHtml = '';
            for (const stageKey of this.STAGES_CONFIG) {
                const data = res.stages[stageKey];
                if (data.completed || data.errors > 0) {
                    stageHtml += `
                        <div class="mt-3">
                            <p class="font-semibold text-gray-800">Estágio de ${stageKey} padrões:</p>
                            <p class="ml-4">Erros: ${data.errors}</p>
                            <p class="ml-4">Acertos na 1ª Tentativa (Item): ${data.firstAttemptSuccesses} de ${stageKey}</p>
                        </div>`;
                }
            }
            this.ui.stageResults.innerHTML = stageHtml;
        }

        getResultsObject(type = 'detailed') {
            const res = this.state.results;
            const summary = {
                subjectID: res.subjectID,
                nivelMaximoConcluido1aApresentacao: res.stagesCompleted,
                totalErros_PALTE: res.totalErrors,
                totalErrosAjustado_PALTEA: res.PALTEA,
                errosMediosParaSucesso_PALMETS: res.PALMETS,
                totalAcertos1aTentativa_Item: res.totalFirstAttemptSuccesses,
            };
            if (type === 'summary') {
                return { resumoGeral: summary };
            }
            const stageDetails = {};
            for (const stageKey of this.STAGES_CONFIG) {
                const data = res.stages[stageKey];
                if (data.completed || data.errors > 0) {
                    stageDetails[stageKey] = {
                        erros: data.errors,
                        acertos1aTentativa_Item: data.firstAttemptSuccesses,
                        totalPadroes: parseInt(stageKey)
                    };
                }
            }
            return {
                resumoGeral: summary,
                desempenhoPorEstagio: stageDetails,
                logDetalhado: res.trialLog
            };
        }
        
        exportController(format, type) {
            const subjectID = this.state.results.subjectID;
            if (!subjectID) {
                alert("ID do sujeito não encontrado. A exportação foi cancelada.");
                return;
            }
            const date = new Date().toISOString().split('T')[0];
            const filename = `PAL_${subjectID}_${date}_${type}`;

            switch (format) {
                case 'csv': this.exportCSV(filename, type); break;
                case 'json': this.exportJSON(filename, type); break;
                case 'pdf': this.exportPDF(filename, type); break;
            }
        }

        downloadFile(content, fileName, contentType) {
            const a = document.createElement("a");
            const file = new Blob([content], { type: contentType });
            a.href = URL.createObjectURL(file);
            a.download = fileName;
            a.click();
            URL.revokeObjectURL(a.href);
        }

        exportCSV(filename, type) {
            const results = this.getResultsObject(type);
            let csvContent = "";
            const summary = results.resumoGeral;
            csvContent += "Metrica,Valor\r\n";
            Object.entries(summary).forEach(([key, value]) => {
                csvContent += `${key},${value}\r\n`;
            });

            if (type === 'detailed') {
                csvContent += "\r\nLog Detalhado\r\n";
                const headers = ["Stage", "StimulusID", "CorrectPosition", "ClickedPosition", "IsCorrect", "Presentation", "AttemptNumber", "ResponseTime_ms"];
                csvContent += headers.join(",") + "\r\n";
                results.logDetalhado.forEach(log => {
                    const row = [log.stage, log.stimulusId, log.correctPosition, log.clickedPosition, log.isCorrect, log.presentation, log.attempt, log.responseTime];
                    csvContent += row.join(",") + "\r\n";
                });
            }
            this.downloadFile(csvContent, `${filename}.csv`, 'text/csv;charset=utf-8;');
        }
        
        exportJSON(filename, type) {
            const results = this.getResultsObject(type);
            const jsonContent = JSON.stringify(results, null, 2);
            this.downloadFile(jsonContent, `${filename}.json`, 'application/json');
        }

        exportPDF(filename, type) {
            if (typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined') {
                return alert("Erro: A biblioteca para gerar PDF não foi carregada.");
            }
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const results = this.getResultsObject(type);
            const summary = results.resumoGeral;

            doc.setFontSize(18);
            doc.text("Relatório do Teste de Memória Associativa (PAL)", 14, 22);
            doc.setFontSize(11);
            doc.setTextColor(100);
            doc.text(`Data: ${new Date().toLocaleString('pt-BR')}`, 14, 28);
            doc.text(`ID do Sujeito: ${summary.subjectID}`, 14, 34);
            
            doc.autoTable({
                startY: 40,
                head: [['Métrica', 'Valor']],
                body: Object.entries(summary).map(([key, value]) => [key.replace(/_/g, ' '), value]),
                theme: 'striped'
            });

            if (type === 'detailed') {
                doc.addPage();
                doc.setFontSize(16);
                doc.text("Log Detalhado de Tentativas", 14, 22);
                const head = [['Estágio', 'Estímulo', 'Pos. Correta', 'Pos. Clicada', 'Correto?', 'Apres.', 'Tentativa', 'Tempo (ms)']];
                const body = results.logDetalhado.map(log => [
                    log.stage, log.stimulusId, log.correctPosition, log.clickedPosition, 
                    log.isCorrect ? 'Sim' : 'Não', log.presentation, log.attempt, log.responseTime
                ]);
                doc.autoTable({ startY: 30, head: head, body: body, theme: 'grid' });
            }
            doc.save(`${filename}.pdf`);
        }
        
        shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
    }

    document.addEventListener('DOMContentLoaded', () => { new PALTest(); });
    </script>
</body>
</html>
